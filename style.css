(() => {
  const $ = (id) => document.getElementById(id);

  /* =========================
     Stable viewport height (iOS)
  ========================= */
  function setVH(){
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty("--vh", `${vh}px`);
  }
  setVH();
  window.addEventListener("resize", setVH, { passive: true });

  /* =========================
     Elements
  ========================= */
  const viewport = $("carouselViewport");
  const track = $("carouselTrack");
  const tripDotsWrap = $("tripDots");
  const tripDots = Array.from(tripDotsWrap.querySelectorAll(".tDot"));

  const edgeZone = $("edgeZone");
  const edgeSelector = $("edgeSelector");
  const edgeDotsWrap = $("edgeDots");
  const edgePicker = $("edgePicker");
  const edgeBackdrop = $("edgeBackdrop");

  const dateWeekday = $("dateWeekday");
  const dateDayMonth = $("dateDayMonth");

  const SLIDE_COUNT = 9;

  /* =========================
     Date (auto, sv-SE)
  ========================= */
  function capFirst(s){
    if(!s) return s;
    return s.charAt(0).toUpperCase() + s.slice(1);
  }
  function renderDate(){
    const d = new Date();
    const weekday = capFirst(new Intl.DateTimeFormat("sv-SE", { weekday: "long" }).format(d));
    const day = new Intl.DateTimeFormat("sv-SE", { day: "numeric" }).format(d);
    const month = capFirst(new Intl.DateTimeFormat("sv-SE", { month: "long" }).format(d));
    dateWeekday.textContent = weekday;
    dateDayMonth.textContent = `${day} ${month}`;
  }
  renderDate();
  // update shortly after midnight as well
  setInterval(renderDate, 60_000);

  /* =========================
     State
  ========================= */
  let index = 0;

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function getWidth(){
    return viewport.getBoundingClientRect().width || 1;
  }

  function setTripDots(i){
    // 3 dots represent groups of 3 slides: 0-2, 3-5, 6-8
    const group = Math.floor(i / 3);
    tripDots.forEach((d, idx) => d.classList.toggle("isActive", idx === group));
  }

  function snapTo(i, animate = true){
    index = clamp(i, 0, SLIDE_COUNT - 1);
    const w = getWidth();
    const x = -index * w;

    if(animate){
      track.style.transition = "transform 240ms cubic-bezier(.2,.9,.2,1)";
      viewport.style.transition = "opacity 180ms ease";
    }else{
      track.style.transition = "";
      viewport.style.transition = "";
    }

    track.style.transform = `translate3d(${x}px,0,0)`;
    viewport.style.opacity = "1";

    // cleanup transition after
    if(animate){
      window.setTimeout(() => {
        track.style.transition = "";
        viewport.style.transition = "";
      }, 260);
    }

    setTripDots(index);
    updateEdgePickerToIndex(index, true);
  }

  /* =========================
     Carousel swipe (pointer events)
  ========================= */
  let dragging = false;
  let startX = 0;
  let dx = 0;
  let pointerId = null;

  function setDragTransform(dxNow){
    const w = getWidth();
    const x = (-index * w) + dxNow;
    track.style.transform = `translate3d(${x}px,0,0)`;

    // fade whole screen slightly while dragging (premium)
    const p = Math.min(1, Math.abs(dxNow) / w);
    viewport.style.opacity = String(1 - 0.28 * p); // 1 -> 0.72 max
  }

  viewport.addEventListener("pointerdown", (e) => {
    // if edge selector is active, ignore carousel drag
    if(document.body.classList.contains("edgeActive")) return;

    dragging = true;
    pointerId = e.pointerId;
    startX = e.clientX;
    dx = 0;

    viewport.setPointerCapture(pointerId);
    track.style.transition = "";
    viewport.style.transition = "";
  });

  viewport.addEventListener("pointermove", (e) => {
    if(!dragging || e.pointerId !== pointerId) return;

    dx = e.clientX - startX;

    // resistance at ends
    if((index === 0 && dx > 0) || (index === SLIDE_COUNT - 1 && dx < 0)){
      dx *= 0.35;
    }

    setDragTransform(dx);
  });

  function endDrag(){
    if(!dragging) return;
    dragging = false;

    const w = getWidth();
    const p = Math.abs(dx) / w;

    let next = index;
    if(p > 0.18){
      next = dx < 0 ? index + 1 : index - 1;
    }
    snapTo(next, true);

    dx = 0;
    pointerId = null;
  }

  viewport.addEventListener("pointerup", (e) => {
    if(e.pointerId !== pointerId) return;
    endDrag();
  });

  viewport.addEventListener("pointercancel", (e) => {
    if(e.pointerId !== pointerId) return;
    endDrag();
  });

  // Keep position correct on resize/orientation change
  window.addEventListener("resize", () => snapTo(index, false), { passive: true });

  /* =========================
     Edge selector (rubber band) – design locked:
     - only appears during edge swipe
     - threshold to activate
     - 9 dots + turquoise filled picker
     - same index system as carousel
  ========================= */
  // render 9 dots
  const edgeDots = [];
  for(let i=0;i<SLIDE_COUNT;i++){
    const d = document.createElement("div");
    d.className = "edgeDot";
    edgeDotsWrap.appendChild(d);
    edgeDots.push(d);
  }

  function getEdgeDotsGeometry(){
    const rects = edgeDots.map(d => d.getBoundingClientRect());
    const centersY = rects.map(r => r.top + r.height/2);
    const minY = Math.min(...centersY);
    const maxY = Math.max(...centersY);
    return { centersY, minY, maxY };
  }

  function updateEdgePickerToIndex(i, animate){
    const { centersY } = getEdgeDotsGeometry();
    const targetY = centersY[clamp(i,0,SLIDE_COUNT-1)] || (window.innerHeight/2);

    if(animate){
      edgePicker.style.transition = "transform 220ms cubic-bezier(.2,.9,.2,1), opacity 180ms ease";
    }else{
      edgePicker.style.transition = "";
    }

    // edgePicker uses translateY in px, anchored from top via absolute positioning trick:
    // We’ll position it via transform relative to viewport top by setting it as fixed-ish:
    // easiest: put it in fixed coords using translate3d(0, Ypx, 0) minus half.
    edgePicker.style.transform = `translate3d(0, ${targetY - (window.innerHeight/2)}px, 0) translate3d(0,-50%,0)`;

    if(animate){
      window.setTimeout(()=> edgePicker.style.transition = "", 240);
    }
  }

  function setEdgePickerY(clientY){
    const { centersY, minY, maxY } = getEdgeDotsGeometry();
    const y = clamp(clientY, minY, maxY);

    // move picker to y (relative to screen center, as above)
    edgePicker.style.transform = `translate3d(0, ${y - (window.innerHeight/2)}px, 0) translate3d(0,-50%,0)`;

    // choose nearest dot
    let bestI = 0;
    let bestD = Infinity;
    for(let i=0;i<centersY.length;i++){
      const d = Math.abs(centersY[i] - y);
      if(d < bestD){ bestD = d; bestI = i; }
    }
    return bestI;
  }

  // Edge gesture state
  let edgeTracking = false;
  let edgeActive = false;
  let edgeStartX = 0;
  let edgePointerId = null;
  let edgeCandidateIndex = 0;

  const EDGE_THRESHOLD = 22; // px into the screen before activation
  const EDGE_MAX_PULL = 110; // how far panel follows finger (rubber)

  function openEdgeUI(){
    edgeActive = true;
    document.body.classList.add("edgeActive");

    // start hidden then fade in
    edgeSelector.style.transition = "transform 220ms cubic-bezier(.2,.9,.2,1), opacity 180ms ease";
    edgePicker.style.opacity = "1";
    edgePicker.style.transition = "opacity 180ms ease";

    // initial position: slightly off-screen, will be pulled in by finger
    edgeSelector.style.transform = "translate3d(-88%,0,0)";
    edgeSelector.style.opacity = "1";
  }

  function closeEdgeUI(){
    edgeActive = false;
    document.body.classList.remove("edgeActive");

    edgeSelector.style.transition = "transform 180ms ease, opacity 160ms ease";
    edgeSelector.style.transform = "translate3d(-100%,0,0)";
    edgeSelector.style.opacity = "0";

    edgePicker.style.transition = "opacity 140ms ease";
    edgePicker.style.opacity = "0";

    window.setTimeout(() => {
      edgeSelector.style.transition = "";
      edgePicker.style.transition = "";
    }, 220);
  }

  function setEdgePull(px){
    // rubber band: pull in from left based on px (0..EDGE_MAX_PULL)
    const p = clamp(px, 0, EDGE_MAX_PULL);
    const t = -100 + (p / EDGE_MAX_PULL) * 100; // -100% -> 0%
    // We don't go all the way to 0; keep it subtle
    const eased = -100 + (p / EDGE_MAX_PULL) * 92; // -100 -> -8
    edgeSelector.style.transform = `translate3d(${eased}%,0,0)`;
    edgeSelector.style.opacity = "1";
  }

  // start tracking on edge zone only
  edgeZone.addEventListener("pointerdown", (e) => {
    if(edgeTracking) return;
    edgeTracking = true;
    edgePointerId = e.pointerId;
    edgeStartX = e.clientX;
    edgeCandidateIndex = index;

    edgeZone.setPointerCapture(edgePointerId);
  });

  edgeZone.addEventListener("pointermove", (e) => {
    if(!edgeTracking || e.pointerId !== edgePointerId) return;

    const pull = e.clientX - edgeStartX;

    // not activated yet: wait for threshold
    if(!edgeActive){
      if(pull > EDGE_THRESHOLD){
        openEdgeUI();
        // align picker to current slide
        updateEdgePickerToIndex(index, false);
      }else{
        return;
      }
    }

    // active: follow finger
    setEdgePull(pull);

    // move picker vertically with finger
    edgeCandidateIndex = setEdgePickerY(e.clientY);
  });

  function endEdgeGesture(commit){
    if(!edgeTracking) return;
    edgeTracking = false;

    if(edgeActive){
      if(commit){
        snapTo(edgeCandidateIndex, true);
      }
      closeEdgeUI();
    }

    edgePointerId = null;
  }

  edgeZone.addEventListener("pointerup", (e) => {
    if(e.pointerId !== edgePointerId) return;
    endEdgeGesture(true);
  });

  edgeZone.addEventListener("pointercancel", (e) => {
    if(e.pointerId !== edgePointerId) return;
    endEdgeGesture(false);
  });

  // Tap on backdrop closes edge selector (no commit)
  edgeBackdrop.addEventListener("click", () => {
    if(edgeActive) closeEdgeUI();
  });

  /* =========================
     Init
  ========================= */
  snapTo(0, false);
})();
